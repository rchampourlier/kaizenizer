package store

import (
	"database/sql"
	"fmt"
	"log"
	"time"

	_ "github.com/lib/pq" // PG engine for database/sql
)

// BulkSize is the max size of slices sent to the database
// through bulk imports.
const BulkSize = 10000

// PGStore implements the application's `Store` with a
// Postgres DB backend.
type PGStore struct {
	*sql.DB
}

// NewPGStore returns a `PGStore` storing the specified DB.
// The passed DB should already be open and ready to
// receive queries.
func NewPGStore(db *sql.DB) *PGStore {
	return &PGStore{db}
}

// Event represents the event loaded from the database,
// generated by [Jira Source]() (from the
// `jira_issues_events` table).
type Event struct {
	Time      time.Time
	Kind      string
	IssueKey  string
	ValueFrom *string
	ValueTo   *string
}

// Metric represents a metric to be stored to the DB.
type Metric struct {
	Time    time.Time
	Name    string
	Segment string
	Value   float64
}

// WriteMetrics writes a slice of metric records to the database.
// TODO: bulk imports for large slices
func (s *PGStore) WriteMetrics(metrics []Metric) {
	query := `
	INSERT INTO jira_metrics (
		time,
		name,
		segment,
		value
	) 
	VALUES ($1, $2, $3, $4);
	`
	s.exec([]string{query})
}

// StreamEvents will generate a stream of `Event` records from
// the database's `jira_issues_events` table, filtered with a `WHERE`
// clause on the `segmentColumn` and `segmentValue`.
func (s *PGStore) StreamEvents(segmentColumn, segmentValue string) chan Event {
	events := make(chan Event, 0)

	go func() {
		query := fmt.Sprintf(`
		SELECT 
			event_time,
			event_kind,
			issue_key, 
			status_change_from,
			status_change_to,
			assignee_change_from,
			assignee_change_to
		FROM jira_issues_events
		WHERE %s = $1
		`, segmentColumn)
		rows, err := s.Query(query, segmentValue)
		if err != nil {
			log.Fatal(err)
		}
		defer rows.Close()
		for rows.Next() {
			var t time.Time
			var kind, issueKey string
			var statusFrom, statusTo, assigneeFrom, assigneeTo *string
			err := rows.Scan(
				&t,
				&kind,
				&issueKey,
				&statusFrom,
				&statusTo,
				&assigneeFrom,
				&assigneeTo,
			)
			if err != nil {
				log.Fatal(err)
			}

			switch kind {
			case "status_changed":
				events <- Event{t, kind, issueKey, statusFrom, statusTo}
			case "assignee_changed":
				events <- Event{t, kind, issueKey, assigneeFrom, assigneeTo}
			}
		}
		if err := rows.Err(); err != nil {
			log.Fatal(err)
		}
		close(events)
	}()

	return events
}

// CreateTables creates the `jira_metrics` table.
func (s *PGStore) CreateTables() {
	queries := []string{
		`CREATE TABLE "jira_metrics" (
			"id" SERIAL PRIMARY KEY NOT NULL,
			"inserted_at" TIMESTAMP(6) NOT NULL DEFAULT statement_timestamp(),
			"time" TIMESTAMP(6) NOT NULL,
			"kind" TEXT,
			"segment" TEXT,
			"value" DOUBLE PRECISION
		);`,
	}
	err := s.exec(queries)
	if err != nil {
		log.Fatalln(fmt.Errorf("error in `CreateTables`: %s", err))
	}
}

// DropTables drops the tables used by this source
// (`jira_issues_events` and `jira_issues_states`)
func (s *PGStore) DropTables() {
	queries := []string{
		`DROP TABLE IF EXISTS "jira_metrics";`,
	}
	err := s.exec(queries)
	if err != nil {
		log.Fatalln(fmt.Errorf("error in `DropTables()`: %s", err))
	}
}

// exec executes the passed SQL commands on the DB using `Exec`.
func (s *PGStore) exec(cmds []string) (err error) {
	for _, c := range cmds {
		_, err = s.Exec(c)
		if err != nil {
			return
		}
	}
	return
}
